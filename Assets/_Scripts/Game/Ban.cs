using UnityEngine;

namespace YokAI
{
    public static class Ban
    {
        public const int FILES = 3; // X Axis
        public const int RANKS = 4; // Y Axis
        public const int PLAYERS = 2;
        public const int POOLABLES = 3;

        public static int[] Grid;
        public static int[] WhitePool;
        public static int[] BlackPool;
        public static int WhitePoolNextAvailableIndex;
        public static int BlackPoolNextAvailableIndex;

        public static int PlayingColor;
        public static int MoveNumber;
        public static Move LastMove;

        public static int Size => FILES * RANKS;

        public static int[] PiecesBitboards;

        public static bool IsSet => PlayingColor == Piece.WHITE || PlayingColor == Piece.BLACK;

        public static Move INVALID_MOVE = new(0, 0, 0);

        static Ban()
        {
            Reset();
        }

        public static void Reset()
        {
            Grid = new int[Size];
            WhitePool = new int[PLAYERS * POOLABLES];
            BlackPool = new int[PLAYERS * POOLABLES];
            PlayingColor = 0;
            MoveNumber = 0;
            LastMove = INVALID_MOVE;
            PiecesBitboards = new int[] { 0, 0 };
        }

        public static int GetPieceFromCoordinate(int x, int y)
        {
            return Grid[GetGridIndex(x, y)];
        }

        public static int GetGridIndex(int x, int y)
        {
            return y * FILES + x;
        }

        public static Vector2Int GetCoordinates(int index)
        {
            return new Vector2Int()
            {
                x = index % FILES,
                y = index / FILES,
            };
        }

        /// <summary>
        /// Any move coming from the User has to be checked with IsValid before using this method.
        /// It ensures that the move could have been generated by the MoveGenerator.
        /// </summary>
        /// <param name="move"></param>
        public static void MakeMove(Move move)
        {
            if (IsOccupied(move.TargetSquare))
            {
                // Any move coming from MoveGenerator cannot target a square occupied by an ally piece
                // so we already know that it is occupied by an enemy piece.
                if (PlayingColor == Piece.WHITE)
                {
                    WhitePool[WhitePoolNextAvailableIndex] = Grid[move.TargetSquare];
                    ++WhitePoolNextAvailableIndex;
                }
                else if (PlayingColor == Piece.BLACK)
                {
                    BlackPool[BlackPoolNextAvailableIndex] = Grid[move.TargetSquare];
                    ++BlackPoolNextAvailableIndex;
                }
            }

            int startSquareBitboard = 1 << move.StartSquare;
            int targetSquareBitboard = 1 << move.TargetSquare;
            int moveBitboard = startSquareBitboard | targetSquareBitboard;
            PiecesBitboards[(PlayingColor >> 8) - 1] ^= moveBitboard;

            Grid[move.TargetSquare] = move.Piece;
            Grid[move.StartSquare] = Piece.NONE;

            LastMove = move;
            PassTurn();
        }

        public static void PassTurn()
        {
            if (PlayingColor == Piece.BLACK)
            {
                ++MoveNumber;
            }
            PlayingColor = ~PlayingColor;
            PlayingColor &= Piece.COLOR_FILTER;
        }

        public static bool IsOccupied(int gridIndex)
        {
            return Grid[gridIndex] != Piece.NONE;
        }

        public static bool IsValid(Move move)
        {
            MoveGenerator.GenerateMoves();
            return MoveGenerator.Moves.Contains(move);
        }

        public static int GetPieceBitboard(int color)
        {
            return PiecesBitboards[(color >> 8) - 1];
        }
    }
}